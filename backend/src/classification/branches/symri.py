"""
SyMRI Branch Logic

Classification branch for Synthetic MRI (SyMRI/MAGiC) outputs.

SyMRI produces multiple output types from a single quantitative acquisition:

Raw Source (MDME/QALAS):
- Multi-dynamic multi-echo (MDME) - 2D acquisitions, 4 dynamics × 2 echoes
- 3D-QALAS - 3D acquisition variant
- Source data has Magnitude + Phase pairs for T1 polarity detection
- Raw source has NO tissue contrast (base=NULL)

Quantitative Maps:
- T1map, T2map, PDmap - Relaxation time maps
- R1map (1/T1), R2map (1/T2) - Rate maps
- B1map - RF field inhomogeneity map
- All quantitative maps have NO tissue contrast (base=NULL)

Synthetic Weighted Images:
- SyntheticT1w, SyntheticT2w, SyntheticPDw - Standard contrasts
- SyntheticFLAIR, SyntheticDIR, SyntheticPSIR, SyntheticSTIR - IR contrasts
- Synthetic weighted images HAVE tissue contrast (base=T1w/T2w/PDw)

Myelin Maps:
- MyelinMap (MYC token) - Myelin water fraction
- No tissue contrast (base=NULL)

Physics Note:
Synthetic images are generated by applying T1/T2/PD values to a contrast
equation, simulating what a real acquisition would look like. They are
DERIVED but represent real tissue contrast.

Version: 2.0.0 - Complete rewrite following SWI pattern with ImageType token checks
"""

from typing import List, Optional, Tuple

from ..core.context import ClassificationContext
from ..core.evidence import Evidence, EvidenceSource
from .common import BranchResult, SYMRI_OUTPUT_TYPES


def apply_symri_logic(ctx: ClassificationContext) -> BranchResult:
    """
    Apply SyMRI-specific classification logic.

    SyMRI outputs are classified based on ImageType tokens first, then
    text_search_blob keywords as fallback. This follows the SWI branch pattern.

    Key insight: Raw source data and quantitative maps have NO tissue contrast
    (base=NULL). Only synthetic weighted images have base contrast.

    Args:
        ctx: Classification context with fingerprint data

    Returns:
        BranchResult with base/construct overrides for SyMRI outputs

    Detection Priority (first match wins):
        1. Myelin Map
        2. MultiQmap (GE MAGiC bundled T1/T2/PD maps)
        3. Individual Quantitative Maps (T1map, T2map, PDmap, R1map, R2map, B1map)
        4. Synthetic IR Contrasts (FLAIR, DIR, PSIR, STIR)
        5. Synthetic Weighted (T1w, T2w, PDw)
        6. Raw Source - Phase
        7. Raw Source - Magnitude
        8. Fallback - Magnitude (if in SyMRI branch, it's raw data)
    """
    uf = ctx.unified_flags
    pit = ctx.parsed_image_type
    psn = ctx.parsed_sequence_name
    text_blob = (ctx.text_search_blob or "").lower()
    image_type_upper = (ctx.image_type or "").upper()

    # Determine technique (MDME or QALAS)
    symri_technique = "QALAS" if uf.get("is_qalas") or psn.get("is_qalas") else "MDME"

    # =========================================================================
    # 1. Myelin Map (HIGHEST PRIORITY - base=NULL)
    # =========================================================================
    # Myelin must be checked FIRST because MYC token often appears with T1
    # (e.g., DERIVED\PRIMARY\MYC\T1) and we want MyelinMap, not T1map
    if uf.get("has_myelin") or "myelin" in text_blob or "myc" in text_blob:
        return _make_map_result("MyelinMap", "Myelin map detected", symri_technique, "has_myelin")

    # =========================================================================
    # 2. MULTI_QMAP - Bundled T1/T2/PD Maps (GE MAGiC)
    # =========================================================================
    # MULTI_QMAP must be checked BEFORE individual maps because it contains
    # T1, T2, PD tokens that would otherwise trigger individual map detection.
    # Example ImageType: DERIVED\PRIMARY\MULTI_QMAP\ENCRYPTED\T1\T2\PD
    if (uf.get("has_multi_qmap") or
        pit.get("has_multi_qmap") or
        "multi_qmap" in text_blob or
        "qmaps" in text_blob):
        return _make_map_result("MultiQmap", "Combined T1/T2/PD quantitative maps (GE MAGiC)",
                                symri_technique, "has_multi_qmap")

    # =========================================================================
    # 3. Individual Quantitative Maps (base=NULL, no tissue contrast)
    # =========================================================================

    # T1 Map - check QMAP\T1 token, or has_t1_map flag, or text keywords
    if (uf.get("has_qmap_t1") or
        _is_derived_map(pit, "T1") or
        uf.get("has_t1_map") or
        "t1 map" in text_blob or "t1map" in text_blob):
        return _make_map_result("T1map", "T1 map detected", symri_technique,
                                "has_qmap_t1" if uf.get("has_qmap_t1") else "has_t1_map")

    # T2 Map - check QMAP\T2 token, or has_t2_map flag, or text keywords
    if (uf.get("has_qmap_t2") or
        _is_derived_map(pit, "T2") or
        uf.get("has_t2_map") or
        "t2 map" in text_blob or "t2map" in text_blob):
        return _make_map_result("T2map", "T2 map detected", symri_technique,
                                "has_qmap_t2" if uf.get("has_qmap_t2") else "has_t2_map")

    # PD Map - check QMAP\PD token, or has_pd_map flag, or text keywords
    if (uf.get("has_qmap_pd") or
        _is_derived_map(pit, "PD") or
        uf.get("has_pd_map") or
        "pd map" in text_blob or "pdmap" in text_blob or "proton density map" in text_blob):
        return _make_map_result("PDmap", "PD map detected", symri_technique,
                                "has_qmap_pd" if uf.get("has_qmap_pd") else "has_pd_map")

    # R1 Map (1/T1)
    if uf.get("has_r1") or "r1 map" in text_blob or "r1map" in text_blob:
        return _make_map_result("R1map", "R1 map detected", symri_technique, "has_r1")

    # R2 Map (1/T2)
    if uf.get("has_r2") or "r2 map" in text_blob or "r2map" in text_blob:
        return _make_map_result("R2map", "R2 map detected", symri_technique, "has_r2")

    # B1 Map
    if uf.get("has_b1_map") or "b1 map" in text_blob or "b1map" in text_blob:
        return _make_map_result("B1map", "B1 map detected", symri_technique, "has_b1_map",
                                directory_type="fmap")

    # =========================================================================
    # 4. Synthetic IR Contrasts (base=T1w/T2w with modifiers)
    # =========================================================================

    # Synthetic FLAIR - check unified_flags or text keywords
    if (uf.get("has_flair_synthetic") or
        pit.get("has_flair_synthetic") or
        "flair" in text_blob and "synthetic" in text_blob):
        return _make_synthetic_result("T2w", "SyntheticFLAIR", ["FLAIR"], symri_technique,
                                      "has_flair_synthetic", "Synthetic FLAIR")

    # Synthetic DIR - handles both DIR\SYNTHETIC and DIR_SYNTHETIC patterns
    if (uf.get("has_dir_synthetic") or
        pit.get("has_dir_synthetic_token") or
        "dir" in text_blob and "synthetic" in text_blob):
        return _make_synthetic_result("T2w", "SyntheticDIR", ["DIR"], symri_technique,
                                      "has_dir_synthetic", "Synthetic DIR")

    # Synthetic PSIR - handles both PSIR\SYNTHETIC and PSIR_SYNTHETIC patterns
    if (uf.get("has_psir_synthetic") or
        pit.get("has_psir_synthetic_token") or
        "psir" in text_blob and "synthetic" in text_blob):
        return _make_synthetic_result("T1w", "SyntheticPSIR", ["PSIR"], symri_technique,
                                      "has_psir_synthetic", "Synthetic PSIR")

    # Synthetic STIR
    if (uf.get("has_stir_synthetic") or
        "stir" in text_blob and "synthetic" in text_blob):
        return _make_synthetic_result("T2w", "SyntheticSTIR", ["STIR"], symri_technique,
                                      "has_stir_synthetic", "Synthetic STIR")

    # =========================================================================
    # 5. Synthetic Weighted Images (base with construct)
    # =========================================================================

    # Synthetic T1w - check for T1\SYNTHETIC or T1W_SYNTHETIC patterns
    if (uf.get("has_t1_synthetic") or
        _is_synthetic_weighted(pit, "T1") or
        ("t1" in text_blob and "synthetic" in text_blob and
         "flair" not in text_blob and "dir" not in text_blob and "psir" not in text_blob)):
        return _make_synthetic_result("T1w", "SyntheticT1w", [], symri_technique,
                                      "has_t1_synthetic", "Synthetic T1w")

    # Synthetic T2w - check for T2\SYNTHETIC or T2W_SYNTHETIC patterns
    if (uf.get("has_t2_synthetic") or
        _is_synthetic_weighted(pit, "T2") or
        ("t2" in text_blob and "synthetic" in text_blob and
         "flair" not in text_blob and "stir" not in text_blob)):
        return _make_synthetic_result("T2w", "SyntheticT2w", [], symri_technique,
                                      "has_t2_synthetic", "Synthetic T2w")

    # Synthetic PDw - check for PD\SYNTHETIC or PDW_SYNTHETIC patterns
    if (uf.get("has_pd_synthetic") or
        _is_synthetic_weighted(pit, "PDW") or
        ("pd" in text_blob and "synthetic" in text_blob)):
        return _make_synthetic_result("PDw", "SyntheticPDw", [], symri_technique,
                                      "has_pd_synthetic", "Synthetic PDw")

    # =========================================================================
    # 6. Raw Source - Phase (base=NULL)
    # =========================================================================
    # Check for Phase token in ImageType (P, PHASE, PHASE MAP)
    # Phase is more specific, so check before Magnitude
    is_phase_imagetype = (
        uf.get("has_phase") and not uf.get("has_magnitude")
    ) or "PHASE MAP" in image_type_upper
    is_phase_text = "phase" in text_blob and "magnitude" not in text_blob

    if is_phase_imagetype or is_phase_text:
        return BranchResult(
            base=None,
            construct="Phase",
            technique=symri_technique,
            skip_base_detection=True,
            skip_construct_detection=True,
            skip_technique_detection=True,
            directory_type="anat",
            confidence=0.90,
            evidence=[Evidence(
                source=EvidenceSource.HIGH_VALUE_TOKEN,
                field="image_type" if is_phase_imagetype else "text_search_blob",
                value="phase token" if is_phase_imagetype else "phase keyword",
                target="Phase",
                weight=0.90,
                description="SyMRI raw phase data",
            )],
        )

    # =========================================================================
    # 7. Raw Source - Magnitude (base=NULL)
    # =========================================================================
    # Check for Magnitude token in ImageType (M, M_SE, MAGIC)
    is_magnitude_imagetype = (
        uf.get("has_magnitude") or
        uf.get("is_magic_raw") or
        "M_SE" in image_type_upper
    )
    is_magnitude_text = "magnitude" in text_blob

    if is_magnitude_imagetype or is_magnitude_text:
        return BranchResult(
            base=None,
            construct="Magnitude",
            technique=symri_technique,
            skip_base_detection=True,
            skip_construct_detection=True,
            skip_technique_detection=True,
            directory_type="anat",
            confidence=0.85,
            evidence=[Evidence(
                source=EvidenceSource.HIGH_VALUE_TOKEN,
                field="image_type" if is_magnitude_imagetype else "text_search_blob",
                value="magnitude token" if is_magnitude_imagetype else "magnitude keyword",
                target="Magnitude",
                weight=0.85,
                description="SyMRI raw magnitude data",
            )],
        )

    # =========================================================================
    # 8. Fallback - Default to Magnitude (we're in SyMRI branch)
    # =========================================================================
    # If we reach here, we're in SyMRI branch but can't determine specific type
    # Most likely raw source data - default to Magnitude with lower confidence
    return BranchResult(
        base=None,
        construct="Magnitude",
        technique=symri_technique,
        skip_base_detection=True,
        skip_construct_detection=True,
        skip_technique_detection=True,
        directory_type="anat",
        confidence=0.70,
        evidence=[Evidence(
            source=EvidenceSource.HIGH_VALUE_TOKEN,
            field="provenance",
            value="SyMRI",
            target="Magnitude",
            weight=0.70,
            description="SyMRI branch, output type unclear → default to Magnitude (raw source)",
        )],
    )


# =============================================================================
# Helper Functions
# =============================================================================

def _is_derived_map(pit: dict, map_type: str) -> bool:
    r"""
    Check if ImageType indicates a derived map (e.g., DERIVED\PRIMARY\T1).

    This catches plain derived maps that don't have the QMAP prefix but are
    still quantitative maps (e.g., DERIVED\PRIMARY\T1 for T1 map).

    Args:
        pit: Parsed image type dictionary
        map_type: The map type to check (e.g., "T1", "T2", "PD")

    Returns:
        True if this is a derived map of the specified type
    """
    tokens = pit.get("all_tokens", set())
    return (
        pit.get("is_derived") and
        map_type in tokens and
        "SYNTHETIC" not in tokens and
        "QMAP" not in tokens and
        # Exclude synthetic weighted (T1W_SYNTHETIC, etc.)
        f"{map_type}W_SYNTHETIC" not in tokens
    )


def _is_synthetic_weighted(pit: dict, weight_type: str) -> bool:
    r"""
    Check if ImageType indicates synthetic weighted (e.g., T1\SYNTHETIC).

    This catches synthetic weighted images that have both the weight type
    and SYNTHETIC tokens but are not IR contrasts (FLAIR, DIR, PSIR, STIR).

    Args:
        pit: Parsed image type dictionary
        weight_type: The weight type to check (e.g., "T1", "T2", "PDW")

    Returns:
        True if this is a synthetic weighted image of the specified type
    """
    tokens = pit.get("all_tokens", set())
    return (
        pit.get("is_derived") and
        (weight_type in tokens or f"{weight_type}W" in tokens) and
        "SYNTHETIC" in tokens and
        "FLAIR" not in tokens and
        "DIR" not in tokens and
        "PSIR" not in tokens and
        "STIR" not in tokens
    )


def _make_map_result(
    construct: str,
    description: str,
    technique: str,
    flag_name: str,
    directory_type: str = "anat"
) -> BranchResult:
    """
    Create BranchResult for a quantitative map (no base contrast).

    All quantitative maps have base=NULL because they represent parametric
    values (T1 in ms, T2 in ms, PD in arbitrary units) not tissue contrast.

    Args:
        construct: The construct name (e.g., "T1map", "T2map")
        description: Human-readable description
        technique: The SyMRI technique ("MDME" or "QALAS")
        flag_name: The flag that triggered this detection
        directory_type: Output directory type (default "anat")

    Returns:
        BranchResult with appropriate settings
    """
    return BranchResult(
        base=None,
        construct=construct,
        technique=technique,
        skip_base_detection=True,
        skip_construct_detection=True,
        skip_technique_detection=True,
        directory_type=directory_type,
        confidence=0.95,
        evidence=[Evidence(
            source=EvidenceSource.HIGH_VALUE_TOKEN,
            field="unified_flags",
            value=flag_name,
            target=construct,
            weight=0.95,
            description=description,
        )],
    )


def _make_synthetic_result(
    base: str,
    construct: str,
    modifiers: List[str],
    technique: str,
    flag_name: str,
    description: str
) -> BranchResult:
    """
    Create BranchResult for a synthetic weighted image.

    Synthetic weighted images HAVE tissue contrast because they simulate
    what a real acquisition with that weighting would look like.

    Args:
        base: The base contrast (e.g., "T1w", "T2w", "PDw")
        construct: The construct name (e.g., "SyntheticT1w")
        modifiers: List of modifiers to add (e.g., ["FLAIR"])
        technique: The SyMRI technique ("MDME" or "QALAS")
        flag_name: The flag that triggered this detection
        description: Human-readable description

    Returns:
        BranchResult with appropriate settings
    """
    return BranchResult(
        base=base,
        construct=construct,
        modifiers_add=modifiers if modifiers else None,
        technique=technique,
        skip_base_detection=True,
        skip_construct_detection=True,
        skip_technique_detection=True,
        directory_type="anat",
        confidence=0.95,
        evidence=[Evidence(
            source=EvidenceSource.HIGH_VALUE_TOKEN,
            field="unified_flags",
            value=flag_name,
            target=construct,
            weight=0.95,
            description=f"{description} → {base} base",
        )],
    )


# =============================================================================
# Detection Helper Functions
# =============================================================================

def detect_symri_output_type(ctx: ClassificationContext) -> Optional[str]:
    """
    Detect which SyMRI output type this stack represents.

    Args:
        ctx: Classification context

    Returns:
        Output type key from SYMRI_OUTPUT_TYPES, or None if unknown
    """
    uf = ctx.unified_flags
    pit = ctx.parsed_image_type
    psn = ctx.parsed_sequence_name
    text_blob = (ctx.text_search_blob or "").lower()

    # Priority order matches apply_symri_logic

    # 1. Myelin (HIGHEST PRIORITY)
    if uf.get("has_myelin") or "myelin" in text_blob or "myc" in text_blob:
        return "myelin_map"

    # 2. MultiQmap (GE MAGiC bundled T1/T2/PD maps) - before individual maps
    if (uf.get("has_multi_qmap") or pit.get("has_multi_qmap") or
        "multi_qmap" in text_blob or "qmaps" in text_blob):
        return "multi_qmap"

    # 3. Individual Quantitative maps
    if uf.get("has_qmap_t1") or _is_derived_map(pit, "T1") or uf.get("has_t1_map"):
        return "t1_map"
    if uf.get("has_qmap_t2") or _is_derived_map(pit, "T2") or uf.get("has_t2_map"):
        return "t2_map"
    if uf.get("has_qmap_pd") or _is_derived_map(pit, "PD") or uf.get("has_pd_map"):
        return "pd_map"
    if uf.get("has_r1"):
        return "r1_map"
    if uf.get("has_r2"):
        return "r2_map"
    if uf.get("has_b1_map"):
        return "b1_map"

    # Synthetic IR contrasts
    if uf.get("has_flair_synthetic"):
        return "synthetic_flair"
    if uf.get("has_dir_synthetic"):
        return "synthetic_dir"
    if uf.get("has_psir_synthetic"):
        return "synthetic_psir"
    if uf.get("has_stir_synthetic"):
        return "synthetic_stir"

    # Synthetic weighted
    if uf.get("has_t1_synthetic"):
        return "synthetic_t1w"
    if uf.get("has_t2_synthetic"):
        return "synthetic_t2w"
    if uf.get("has_pd_synthetic"):
        return "synthetic_pdw"

    # Raw source
    if uf.get("has_phase") and not uf.get("has_magnitude"):
        return "phase"
    if uf.get("has_magnitude"):
        return "magnitude"

    # Source MDME/QALAS
    if uf.get("is_symri_source"):
        if psn.get("is_qalas"):
            return "source_qalas"
        return "source_mdme"

    return "magnitude"  # Default to magnitude


def get_symri_output_info(output_type: str) -> dict:
    """
    Get information about a SyMRI output type.

    Args:
        output_type: Key from SYMRI_OUTPUT_TYPES

    Returns:
        Dict with base, construct, description, modifiers (optional)
    """
    return SYMRI_OUTPUT_TYPES.get(output_type, {
        "base": None,
        "construct": "Magnitude",
        "description": "SyMRI raw source data",
    })


def classify_symri_complex_data(
    ctx: ClassificationContext
) -> Tuple[Optional[str], Optional[str]]:
    """
    Classify SyMRI complex data (magnitude + phase pairs).

    MDME raw source consists of magnitude and phase pairs for each
    dynamic/echo combination. This function determines which component
    this stack represents.

    Args:
        ctx: Classification context

    Returns:
        Tuple of (component_type, echo_info)
        component_type: "magnitude" or "phase"
        echo_info: e.g., "echo1_dyn1" or None if not determinable
    """
    uf = ctx.unified_flags

    component = None
    if uf.get("has_phase") and not uf.get("has_magnitude"):
        component = "phase"
    elif uf.get("has_magnitude"):
        component = "magnitude"
    else:
        component = "magnitude"  # Default

    # Echo/dynamic info would come from stack_key or other metadata
    echo_info = None
    if ctx.stack_key and "echo" in ctx.stack_key.lower():
        echo_info = ctx.stack_key

    return (component, echo_info)
